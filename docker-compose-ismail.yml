services:

  frontend:
    build:
      context: ./cirrostrats-frontend
      dockerfile: Dockerfile.frontend
      # THIS IS THE KEY: It tells Docker which stage to build
      target: ${BUILD_TARGET:-development} 
      args:
        - VITE_API_URL=${VITE_API_URL}
        - VITE_JMS_API_URL=${VITE_JMS_API_URL}
        - VITE_ENV=${VITE_ENV}
        - VITE_APP_AVOID_FLIGHT_AWARE=${VITE_APP_AVOID_FLIGHT_AWARE}
        - VITE_EDCT_FETCH=${VITE_EDCT_FETCH}
        - VITE_APP_TEST_FLIGHT_DATA=${VITE_APP_TEST_FLIGHT_DATA}
    ports:
      # Maps Host 5173 -> Container 80 (Used by both Dev and Prod now)
      - "5173:80"
    volumes:
      # This volume is safe! 
      # In Dev: It mounts code to /app (where Node runs).
      # In Prod: It mounts code to /app (but Nginx serves from /usr/share/nginx/html, so this is ignored).
      - ./cirrostrats-frontend:/app
      - node_modules:/app/node_modules
    networks:
      - base-network

  backend:
    build:
    # Build the docker image from the Dockerfile.backend in the cirrostrats-backend directory
      context: ./cirrostrats-backend
      dockerfile: Dockerfile.backend
    ports:
      # Format is "HOST_PORT:CONTAINER_PORT"
      - "8000:8000"
    volumes:
      - ./cirrostrats-backend:/app
    networks:
      - base-network
      # - observability
    labels:
      - "traefik.enable=true"
      - "prometheus.scrape=true"
      - "prometheus.port=8080"  # Your metrics port
      - "prometheus.path=/metrics"

  nginx:
    image: nginx
    ports:
      # Format is "HOST_PORT:CONTAINER_PORT"
      - "80:80"
    volumes:    # If working on nginx and want changes to be reflected in the container, use the volumes
      - ./nginx/nginx.conf:/etc/nginx/nginx.conf
    # TODO: Check what the difference is between the above^^ and this - ./nginx/nginx.conf:/etc/nginx/conf.d/default.conf
    depends_on:
      - frontend
      - backend
    networks:
      - base-network
      # - observability
  
  redis:
    # deploy:   # This was used previously to prevent it from spawning in development. Accompany with .env file and set Run_Celery=1 if using this feature in production.
      # replicas: ${RUN_CELERY:-0}  # Defaults to 0 containers: no Celery in development
    image: redis
    ports:
      # Format is "HOST_PORT:CONTAINER_PORT"
      - "6379:6379"     # TODO: What is the significance of this port?
    networks:
      - base-network
    profiles:     # use docker compose --profile production up in the production environment
      - production

  celery:
    # deploy:   # This was used previously to prevent it from spawning in development. Accompany with .env file and set Run_Celery=1 if using this feature in production.
      # replicas: ${RUN_CELERY:-0}  # Defaults to 0 containers: no Celery in development
    container_name: celery_worker
    build:
      context: ./cirrostrats-backend      # This is where the celery_app.py file is
      dockerfile: routes/Dockerfile.celery   # use this if you want to build the docker image from the Dockerfile.celery and isolate the command from the rest of the Dockerfile
    command: celery -A routes.celery_app worker --loglevel=info      # Execute the tasks defined in celery_app.py This takes preecedence over the dockerfile command
    depends_on:
      - redis
    volumes:      # Changes are not reflected instantly in celery. Restart container to see changes.
      - ./cirrostrats-backend:/app
    networks:
      - base-network
    profiles:     # use docker compose --profile production up in the production environment
      - production

  celery-beat:
    # deploy:   # This was used previously to prevent it from spawning in development. Accompany with .env file and set Run_Celery=1 if using this feature in production.
      # replicas: ${RUN_CELERY:-0}  # Defaults to 0 containers: no Celery in development
    container_name: celery_beat
    build:
      context: ./cirrostrats-backend      # This is where the celery_app.py file is
      dockerfile: routes/Dockerfile.celery
    command: celery -A routes.celery_app beat --loglevel=info      # This takes preecedence over the dockerfile command
    depends_on:
      - redis
      - celery
    volumes:      # Changes are not reflected instantly in celery. Restart container to see changes.
      - ./cirrostrats-backend:/app
    networks:
      - base-network
    profiles:     # use docker compose --profile production up in the production environment
      - production


networks:
  # observability:
  #   external: true
  base-network:
    driver: bridge

volumes:
  node_modules:

